#!/bin/bash

# Script de Testes Cient√≠ficos Automatizados - ESP32-CAM
# Gabriel Passos - UNESP 2025

set -e

# Salvar diret√≥rio raiz do projeto
PROJECT_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo -e "${BLUE}========================================${NC}"
echo -e "${BLUE}üî¨ Testes Cient√≠ficos ESP32-CAM${NC}"
echo -e "${BLUE}üìä Coleta de Dados para Artigo${NC}"
echo -e "${BLUE}Gabriel Passos - UNESP 2025${NC}"
echo -e "${BLUE}========================================${NC}"

# Verificar se estamos no diret√≥rio correto
if [ -f "../esp32/main/main.c" ] && [ -f "../server/mqtt_data_collector.py" ]; then
    # Executado de dentro da pasta scripts/
    cd ..
elif [ ! -f "esp32/main/main.c" ] || [ ! -f "server/mqtt_data_collector.py" ]; then
    # N√£o est√° nem na raiz nem em scripts/
    echo -e "${RED}‚ùå Erro: Execute este script a partir da pasta raiz do projeto${NC}"
    echo -e "${YELLOW}üí° Use: ./scripts/run_scientific_tests.sh${NC}"
    exit 1
fi

# Fun√ß√£o para verificar se o servidor est√° rodando
check_server() {
    if pgrep -f "mqtt_data_collector.py" > /dev/null; then
        return 0
    else
        return 1
    fi
}

# Fun√ß√£o para iniciar servidor de monitoramento
start_monitoring_server() {
    local version=$1
    local test_name=$2
    local session_id=$3
    
    echo -e "${YELLOW}üì° Iniciando servidor de monitoramento cient√≠fico...${NC}"
    
    # Criar diret√≥rios necess√°rios
    mkdir -p logs
    
    cd server
    
    # Verificar depend√™ncias Python
    if ! python3 -c "import paho.mqtt.client, sqlite3, json" 2>/dev/null; then
        echo -e "${YELLOW}üì¶ Instalando depend√™ncias Python...${NC}"
        pip3 install paho-mqtt sqlite3 || echo "Algumas depend√™ncias podem j√° estar instaladas"
    fi
    
    # Gerar ID de sess√£o se n√£o fornecido
    if [ -z "$session_id" ]; then
        session_id="${version}_$(date +%Y%m%d_%H%M%S)"
    fi
    
    # Iniciar servidor em background com par√¢metros de sess√£o
    if [ -n "$version" ]; then
        echo -e "${BLUE}üîí Iniciando monitor com vers√£o for√ßada: $version${NC}"
        echo -e "${BLUE}üéØ Sess√£o de teste: $session_id${NC}"
        echo -e "${BLUE}üìù Nome do teste: $test_name${NC}"
        
        nohup python3 mqtt_data_collector.py \
            --version "$version" \
            --session "$session_id" \
            --test-name "$test_name" \
            > ../logs/monitor_debug.log 2>&1 &
    else
        echo -e "${BLUE}üîç Iniciando monitor com detec√ß√£o autom√°tica${NC}"
        nohup python3 mqtt_data_collector.py \
            --session "$session_id" \
            --test-name "$test_name" \
            > ../logs/monitor_debug.log 2>&1 &
    fi
    SERVER_PID=$!
    
    cd ..
    
    # Aguardar servidor inicializar
    sleep 5
    
    if check_server; then
        echo -e "${GREEN}‚úÖ Servidor de monitoramento iniciado (PID: $SERVER_PID)${NC}"
        echo -e "${GREEN}üìù Sess√£o: $session_id${NC}"
        echo $SERVER_PID > .server_pid
        echo $session_id > .current_session
        return 0
    else
        echo -e "${RED}‚ùå Falha ao iniciar servidor de monitoramento${NC}"
        return 1
    fi
}

# Fun√ß√£o para parar servidor
stop_monitoring_server() {
    if [ -f ".server_pid" ]; then
        SERVER_PID=$(cat .server_pid)
        if kill $SERVER_PID 2>/dev/null; then
            echo -e "${GREEN}‚úÖ Servidor de monitoramento parado${NC}"
        fi
        rm -f .server_pid
    fi
    
    # Garantir que todos os processos sejam mortos
    pkill -f "mqtt_data_collector.py" 2>/dev/null || true
}

# Fun√ß√£o para compilar e flash vers√£o espec√≠fica
deploy_version() {
    local version=$1
    echo -e "${YELLOW}üîÑ Alternando para vers√£o $version...${NC}"
    
    # Usar script de altern√¢ncia
    if [ "$version" = "intelligent" ]; then
        echo "1" | bash scripts/switch_version.sh
    elif [ "$version" = "simple" ]; then
        echo "2" | bash scripts/switch_version.sh
    else
        echo -e "${RED}‚ùå Vers√£o inv√°lida: $version${NC}"
        return 1
    fi
    
    # Compilar e fazer flash
    echo -e "${YELLOW}üî® Compilando vers√£o $version...${NC}"
    cd esp32
    
    if idf.py build; then
        echo -e "${GREEN}‚úÖ Compila√ß√£o bem-sucedida${NC}"
        
        echo -e "${YELLOW}üì± Fazendo flash da vers√£o $version...${NC}"
        echo -e "${BLUE}üîå Conecte o ESP32-CAM e pressione ENTER quando estiver pronto${NC}"
        read -p "Pressione ENTER para continuar..."
        
        if idf.py flash; then
            echo -e "${GREEN}‚úÖ Flash bem-sucedido${NC}"
            echo -e "${BLUE}üîÑ Aguarde o ESP32 reinicializar...${NC}"
            sleep 10
            return 0
        else
            echo -e "${RED}‚ùå Falha no flash${NC}"
            return 1
        fi
    else
        echo -e "${RED}‚ùå Falha na compila√ß√£o${NC}"
        return 1
    fi
    
    cd ..
}

# Fun√ß√£o para executar teste
run_test() {
    local version=$1
    local test_name=$2
    local duration=$3
    
    echo -e "${BLUE}üß™ === INICIANDO TESTE: $test_name ($version) ===${NC}"
    echo -e "${BLUE}‚è±Ô∏è  Dura√ß√£o: $duration minutos${NC}"
    echo -e "${BLUE}üìä Coletando dados...${NC}"
    
    # Aguardar estabiliza√ß√£o
    echo -e "${YELLOW}‚è≥ Aguardando estabiliza√ß√£o do sistema (30s)...${NC}"
    sleep 30
    
    # Mostrar countdown
    local seconds=$((duration * 60))
    echo -e "${GREEN}üöÄ Teste iniciado! Monitorando por $duration minutos...${NC}"
    
    # Loop de monitoramento
    local elapsed=0
    while [ $elapsed -lt $seconds ]; do
        local remaining=$((seconds - elapsed))
        local min=$((remaining / 60))
        local sec=$((remaining % 60))
        
        printf "\r${YELLOW}‚è±Ô∏è  Tempo restante: %02d:%02d${NC}" $min $sec
        
        sleep 10
        elapsed=$((elapsed + 10))
        
        # Verificar se o servidor ainda est√° rodando
        if ! check_server; then
            echo -e "\n${RED}‚ùå Servidor de monitoramento parou! Reiniciando...${NC}"
            start_monitoring_server
        fi
    done
    
    echo -e "\n${GREEN}‚úÖ Teste $test_name conclu√≠do!${NC}"
    
    # Aguardar processamento final
    echo -e "${YELLOW}üìä Aguardando processamento final dos dados...${NC}"
    sleep 30
}

# Fun√ß√£o para gerar relat√≥rios
generate_reports() {
    echo -e "${YELLOW}üìä Gerando relat√≥rios cient√≠ficos...${NC}"
    
    # Sempre executar do diret√≥rio raiz
    cd "$PROJECT_ROOT"
    
    # Verificar se existem dados nos bancos
    if [ -f "data/databases/monitoring_intelligent.db" ] || [ -f "data/databases/monitoring_simple.db" ]; then
        # Gerar relat√≥rios
        if python3 scripts/generate_report.py; then
            echo -e "${GREEN}‚úÖ Relat√≥rios gerados com sucesso${NC}"
            
            # Mostrar arquivos gerados
            if [ -d "data/reports" ]; then
                echo -e "${BLUE}üìÅ Arquivos gerados:${NC}"
                ls -la data/reports/
                
                if [ -d "data/reports/plots" ]; then
                    echo -e "${BLUE}üìà Gr√°ficos gerados:${NC}"
                    ls -la data/reports/plots/
                fi
            fi
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Relat√≥rios gerados com dados simulados${NC}"
        fi
    else
        echo -e "${YELLOW}‚ö†Ô∏è  Nenhum dado coletado. Gerando relat√≥rio com dados simulados...${NC}"
        python3 scripts/generate_report.py
    fi
}

# Fun√ß√£o para backup dos dados
backup_data() {
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local backup_dir="backup_scientific_$timestamp"
    
    echo -e "${YELLOW}üíæ Fazendo backup dos dados...${NC}"
    
    mkdir -p "$backup_dir"
    
    # Backup dos bancos de dados
    if [ -f "data/databases/monitoring_intelligent.db" ]; then
        cp "data/databases/monitoring_intelligent.db" "$backup_dir/"
    fi
    
    if [ -f "data/databases/monitoring_simple.db" ]; then
        cp "data/databases/monitoring_simple.db" "$backup_dir/"
    fi
    
    # Backup dos dados
    if [ -d "data" ]; then
        cp -r "data" "$backup_dir/"
    fi
    
    # Backup dos logs
    if [ -d "logs" ]; then
        cp -r "logs" "$backup_dir/"
    fi
    
    echo -e "${GREEN}‚úÖ Backup salvo em: $backup_dir${NC}"
}

# Menu principal
main_menu() {
    echo -e "\n${YELLOW}üî¨ Escolha o tipo de teste:${NC}"
    echo -e "   ${GREEN}1)${NC} Teste Completo Automatizado (2 vers√µes, 3 cen√°rios)"
    echo -e "   ${GREEN}2)${NC} Teste Individual - Vers√£o Inteligente"
    echo -e "   ${GREEN}3)${NC} Teste Individual - Vers√£o Simples"
    echo -e "   ${GREEN}4)${NC} Apenas gerar relat√≥rios dos dados existentes"
    echo -e "   ${GREEN}5)${NC} Backup dos dados coletados"
    echo -e "   ${GREEN}6)${NC} Limpar dados anteriores"
    echo -e "   ${GREEN}0)${NC} Sair"
    
    read -p "üéØ Escolha uma op√ß√£o: " choice
    
    case $choice in
        1)
            run_complete_tests
            ;;
        2)
            run_individual_test "intelligent"
            ;;
        3)
            run_individual_test "simple"
            ;;
        4)
            generate_reports
            ;;
        5)
            backup_data
            ;;
        6)
            clean_previous_data
            ;;
        0)
            echo -e "${GREEN}üëã Saindo...${NC}"
            stop_monitoring_server
            exit 0
            ;;
        *)
            echo -e "${RED}‚ùå Op√ß√£o inv√°lida!${NC}"
            main_menu
            ;;
    esac
}

# Fun√ß√£o para teste completo
run_complete_tests() {
    echo -e "${BLUE}üöÄ === INICIANDO TESTES CIENT√çFICOS COMPLETOS ===${NC}"
    
    # Criar diret√≥rios
    mkdir -p logs
    
    # Teste da vers√£o inteligente
    echo -e "\n${BLUE}üß† === TESTANDO VERS√ÉO INTELIGENTE ===${NC}"
    
    # Iniciar servidor para vers√£o inteligente
    if ! start_monitoring_server "intelligent" "Baseline Est√°tico" "intelligent_baseline_static"; then
        echo -e "${RED}‚ùå Falha ao iniciar monitoramento. Abortando testes.${NC}"
        return 1
    fi
    
    if deploy_version "intelligent"; then
        run_test "intelligent" "Baseline Est√°tico" 10
        echo -e "${BLUE}üìù Anote quaisquer observa√ß√µes sobre o teste...${NC}"
        read -p "Pressione ENTER para continuar para o pr√≥ximo teste..."
        
        run_test "intelligent" "Movimento Controlado" 10
        echo -e "${BLUE}üìù Execute movimentos conforme documentado...${NC}"
        read -p "Pressione ENTER para continuar..."
    fi
    
    # Parar servidor da vers√£o inteligente
    stop_monitoring_server
    
    # Teste da vers√£o simples
    echo -e "\n${BLUE}üì∑ === TESTANDO VERS√ÉO SIMPLES ===${NC}"
    
    # Iniciar servidor para vers√£o simples
    if ! start_monitoring_server "simple" "Baseline Est√°tico" "simple_baseline_static"; then
        echo -e "${RED}‚ùå Falha ao iniciar monitoramento. Abortando testes.${NC}"
        return 1
    fi
    
    if deploy_version "simple"; then
        run_test "simple" "Baseline Est√°tico" 10
        echo -e "${BLUE}üìù Anote quaisquer observa√ß√µes sobre o teste...${NC}"
        read -p "Pressione ENTER para continuar para o pr√≥ximo teste..."
        
        run_test "simple" "Movimento Controlado" 10
        echo -e "${BLUE}üìù Execute os mesmos movimentos do teste anterior...${NC}"
        read -p "Pressione ENTER para continuar..."
    fi
    
    # Parar servidor e gerar relat√≥rios
    stop_monitoring_server
    generate_reports
    backup_data
    
    echo -e "\n${GREEN}üéâ === TESTES CIENT√çFICOS CONCLU√çDOS ===${NC}"
    echo -e "${GREEN}üìä Dados coletados e relat√≥rios gerados${NC}"
    echo -e "${GREEN}üìÅ Verifique a pasta data/reports/ para os resultados${NC}"
}

# Fun√ß√£o para teste individual
run_individual_test() {
    local version=$1
    
    echo -e "${BLUE}üß™ === TESTE INDIVIDUAL: VERS√ÉO $version ===${NC}"
    
    # Gerar ID √∫nico para a sess√£o
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local session_id="${version}_individual_${timestamp}"
    
    # Iniciar servidor de monitoramento com sess√£o espec√≠fica
    if ! start_monitoring_server "$version" "Teste Individual - Vers√£o $version" "$session_id"; then
        echo -e "${RED}‚ùå Falha ao iniciar monitoramento${NC}"
        return 1
    fi
    
    # Alternar para a vers√£o desejada
    if ! deploy_version "$version"; then
        echo -e "${RED}‚ùå Falha ao alternar vers√£o${NC}"
        return 1
    fi
    
    # Menu de testes
    echo -e "${YELLOW}üî¨ Escolha o tipo de teste:${NC}"
    echo "   1) Baseline Est√°tico (10 min)"
    echo "   2) Movimento Controlado (10 min)"
    echo "   3) Cen√°rio Real (30 min)"
    read -p "Escolha: " test_choice
    
    case $test_choice in
        1)
            local test_name="Baseline Est√°tico ($version)"
            local duration=10
            ;;
        2)
            local test_name="Movimento Controlado ($version)"
            local duration=10
            ;;
        3)
            local test_name="Cen√°rio Real ($version)"
            local duration=30
            ;;
        *)
            echo -e "${RED}‚ùå Op√ß√£o inv√°lida${NC}"
            return 1
            ;;
    esac
    
    # Atualizar sess√£o com nome do teste espec√≠fico
    session_id="${version}_$(echo "$test_name" | tr ' ' '_' | tr '[:upper:]' '[:lower:]')_${timestamp}"
    echo $session_id > .current_session
    
    echo -e "${BLUE}üß™ === INICIANDO TESTE: $test_name ===${NC}"
    echo -e "${BLUE}‚è±Ô∏è  Dura√ß√£o: $duration minutos${NC}"
    echo -e "${BLUE}üéØ Sess√£o: $session_id${NC}"
    echo -e "${BLUE}üìä Coletando dados...${NC}"
    
    # Aguardar estabiliza√ß√£o do sistema
    echo -e "${YELLOW}‚è≥ Aguardando estabiliza√ß√£o do sistema (30s)...${NC}"
    sleep 30
    
    # Executar teste
    echo -e "${GREEN}üöÄ Teste iniciado! Monitorando por $duration minutos...${NC}"
    
    # Loop de monitoramento com feedback
    local remaining=$duration
    while [ $remaining -gt 0 ]; do
        echo -e "${YELLOW}‚è±Ô∏è  Tempo restante: $(printf "%02d:%02d" $((remaining/60)) $((remaining%60)))${NC}"
        
        # Verificar se o servidor ainda est√° rodando
        if ! check_server; then
            echo -e "${RED}‚ùå Servidor de monitoramento parou! Reiniciando...${NC}"
            if ! start_monitoring_server "$version" "$test_name" "$session_id"; then
                echo -e "${RED}‚ùå Falha cr√≠tica no monitoramento${NC}"
                return 1
            fi
        fi
        
        sleep 60
        remaining=$((remaining - 1))
    done
    
    echo -e "${GREEN}‚úÖ Teste conclu√≠do!${NC}"
    echo -e "${BLUE}üìä Dados coletados na sess√£o: $session_id${NC}"
    
    # Parar servidor
    stop_monitoring_server
    
    # Oferecer gerar relat√≥rio
    echo -e "${YELLOW}üìà Deseja gerar relat√≥rio desta sess√£o? (s/N)${NC}"
    read -p "Resposta: " generate_report
    if [[ $generate_report =~ ^[Ss]$ ]]; then
        echo -e "${BLUE}üìä Gerando relat√≥rio da sess√£o...${NC}"
        if [ -f "../scripts/test_session_manager.py" ]; then
            python3 ../scripts/test_session_manager.py --export --version "$version" --minutes "$duration" --output "relatorio_${session_id}.json"
        else
            echo -e "${YELLOW}‚ö†Ô∏è  Script de relat√≥rio n√£o encontrado${NC}"
        fi
    fi
    
    return 0
}

# Fun√ß√£o para limpar dados anteriores
clean_previous_data() {
    echo -e "${YELLOW}‚ö†Ô∏è  Esta opera√ß√£o ir√° apagar todos os dados coletados anteriormente${NC}"
    echo -e "${BLUE}‚ÑπÔ∏è  Os READMEs das pastas ser√£o preservados${NC}"
    read -p "Tem certeza? (s/N): " confirm
    
    if [[ $confirm == "s" || $confirm == "S" ]]; then
        echo -e "${YELLOW}üßπ Limpando dados anteriores...${NC}"
        
        # Limpar apenas os dados, mantendo a estrutura de diret√≥rios e READMEs
        rm -f data/databases/*.db 2>/dev/null || true
        rm -f data/images/*/*.jpg 2>/dev/null || true
        rm -f data/images/*/*.jpeg 2>/dev/null || true
        rm -f data/images/*/*.png 2>/dev/null || true
        rm -f data/reports/*.pdf 2>/dev/null || true
        rm -f data/reports/*.html 2>/dev/null || true
        rm -f data/reports/*.json 2>/dev/null || true
        rm -f data/reports/plots/*.png 2>/dev/null || true
        rm -f data/reports/plots/*.jpg 2>/dev/null || true
        
        # Limpar logs mantendo READMEs
        find logs/ -name "*.log" -delete 2>/dev/null || true
        find logs/ -name "*.txt" -delete 2>/dev/null || true
        
        # Limpar arquivos de sess√£o tempor√°rios
        rm -f .current_session 2>/dev/null || true
        rm -f .server_pid 2>/dev/null || true
        
        # Recriar estrutura de diret√≥rios se necess√°rio
        mkdir -p data/databases
        mkdir -p data/images/intelligent
        mkdir -p data/images/simple
        mkdir -p data/reports/plots
        mkdir -p logs
        
        echo -e "${GREEN}‚úÖ Dados limpos (estrutura de diret√≥rios e READMEs preservados)${NC}"
        
        # Verificar se READMEs ainda existem
        if [ -f "data/README.md" ]; then
            echo -e "${GREEN}‚úÖ README da pasta data preservado${NC}"
        fi
        if [ -f "logs/README.md" ]; then
            echo -e "${GREEN}‚úÖ README da pasta logs preservado${NC}"
        fi
    else
        echo -e "${BLUE}‚ÑπÔ∏è  Opera√ß√£o cancelada${NC}"
    fi
}

# Trap para cleanup em caso de interrup√ß√£o
trap 'echo -e "\n${YELLOW}üõë Interrup√ß√£o detectada. Limpando...${NC}"; stop_monitoring_server; exit 1' INT

# Verificar depend√™ncias
echo -e "${YELLOW}üîç Verificando depend√™ncias...${NC}"

if ! command -v python3 &> /dev/null; then
    echo -e "${RED}‚ùå Python3 n√£o encontrado${NC}"
    exit 1
fi

if ! command -v idf.py &> /dev/null; then
    echo -e "${RED}‚ùå ESP-IDF n√£o encontrado${NC}"
    exit 1
fi

echo -e "${GREEN}‚úÖ Depend√™ncias verificadas${NC}"

# Executar menu principal
main_menu 